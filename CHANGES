********************************************************************************

Carte infinie :

La génération de carte n'était que très mal intégrée à la version 1
(et n'était alors qu'une rustine temporaire pour pouvoir tester le reste du
projet), et à donc été revue.

Désormais :
- Chaque Land ("étage") a son propre générateur (ainsi, plusieurs étages peuvent
avoir des générateurs complètement différents)
- C'est le Land lui-même qui appelle son générateur lorsqu'on tente d'accéder
à une case non encore générée (le générateur choisit alors ce qu'il veut générer,
tout ou partie de la carte, mais doit au moins générer la coordonnée demandée).
- Le générateur a accès à l'ensemble des données (il ajoute les Tiles du Land,
mais également les objets aux Data aux coordonnées qu'il génère).
- Le Land et le Generateur sont construits simultanément à la création du jeu
selon des critères spécifiés dans Generator.scala :
pour l'instant, il n'y a que des cartes Default, prenant en argument la taille
de la carte, qui peut être Finite(width, height) ou Infinite.


********************************************************************************

Jouer comme un monstre :

Pour permettre cette extension, nous avons simplement du changer le type du 
personnage-joueur dans les données : il n'est plus forcément un Character, 
mais une Creature quelconque.

Afin que l'IA s'occupe de bouger le joueur lorsque ce dernier contrôle une
tierce entité, la modification du code a entièrement consisté au retrait de la
ligne
"val IA = null"
dans Character.scala.

Cette action et son opposée sont implémentées grâce aux traits que l'on peut trouver dans le fichier
changes.TakeControlAction.

********************************************************************************

Réseau :

Nouveau module communication, qui vient s'interfacer avec les façades
In et Out :

communication.parser : le parseur et les lexèmes du protocole de communication

communication.message : les messages du protocole (chacun correspondant
    à une méthode des interfaces In et Out).
    Distinction entre les messages du serveur vers le client et ceux du
    client vers le serveur. Le traitement des messages consiste en la
    méthode process du message.

communication :
    DistantClient extends Out : le serveur doit utiliser cette classe comme Out.
    DistantController extends In : le client doit utiliser cette classe comme In.
    Pending : attend les réponses d'une demande au serveur
    Connection et ConnectionsManager : classes liées au réseau.

Modification dans le code existant :
L'ensemble des objets transitant entre le moteur de jeu et l'affichage doivent
être traduits facilement en lexèmes du langage.
Ainsi, l'ensemble des éléments de representation ont gagné une méthode lexeme, et
leur objet compagnon une méthode extract.

Il eut été possible de coder ces fonctions dans une architecture séparée (mais 
similaire). Par ailleurs, elles ont été écrites à la va-vite, et il faudrait
factoriser leurs codes.

Afin de faciliter l'implémentation du déploiement client-server, une modification 
importante a été apportée à la façade Out : au lieu d'être implémentée par le contrôleur 
et utilisée par l'interface graphique (jusqu'ici, l'interface graphique demandait les 
informations au contrôleur lorsqu'elle désirait se mettre à jour), c'est désormais 
l'inverse (le contrôleur notifiant l'interface graphique de changements dans les 
données). Néanmoins, celles-ci n'étaient pas absolument nécessaires. Ces modifications 
pourraient également permettre d'optimiser la quantité de données transmises à l'interface
 graphique, en envoyant par exemple seulement les objets qui on changés de place.  

********************************************************************************

Temps-réel : 

Le déroulement du jeu au tour-par-tour faisant partie des invariants que nous avions auparavant définis,
l'implémentation du style temps-réel a demandé quelques modifications :
- Un certain nombre de fonctions du contrôleur pouvant être appelée dans différents threads ont été 
synchronisées
- Quelques autres ont été découpées en de plus petites méthodes afin de factoriser du code

Une fois celles-ci réalisées, le temps-réel a pu être implémenté dans le trait controller.RealTime.

********************************************************************************

Hot seat :

Le HotSeat a été presque entièrement réalisé sans modifications de code existant.

Il se compose de deux Traits :

controller.HotSeatControler : qui étend les fonctionnalités du contrôleur afin de déclencher le changement 
	de joueur après chaque action réalisée, et de signaler à l'interface graphique ce changement.

data.HotSeatGame : qui étend les fonctionnalités de la classe Game afin de gérer
 	une liste de plusieurs joueurs, le joueur « courant » ainsi que le passage au joueur suivant.

Les quelques modifications qui ont été apportées au code existant ont été faites dans le but de rendre certaines
méthodes ou certains attributs extensibles par les différents Traits.

********************************************************************************